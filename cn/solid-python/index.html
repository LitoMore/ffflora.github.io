<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Flora Jiang">
    <meta name="description" content="Flora&#39;s personal website">
    <meta name="keywords" content="blog,data,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="读书笔记：《改善 Python 程序的 91 个建议》(1)"/>
<meta name="twitter:description" content="改善 Python 程序的 91 个建议(1) Content: Chapter 1 建议1：理解Pythonic概念
建议2：编写Pythonic代码
建议3：理解Python与C语言的不同之处
建议4：在代码中适当添加注释
建议5：通过适当添加空行使代码布局更为优雅、合理
建议6：编写函数的4个原则
建议7：将常量集中到一个文件
Chapter 2 建议8：利用assert语句来发现问题
建议9：数据交换值的时候不推荐使用中间变量
建议10：充分利用Lazy evaluation的特性
建议11：理解枚举替代实现的缺陷
建议12：不推荐使用type来进行类型检查
建议13：尽量转换为浮点类型后再做除法
建议14：警惕eval()的安全漏洞
建议15：使用enumerate()获取序列迭代的索引和值
建议16：分清==与is的适用场景
建议17：考虑兼容性，尽可能使用Unicode
建议18：构建合理的包层次来管理module
Chapter 3 建议19：有节制地使用from&hellip;import语句
建议20：优先使用absolute import来导入模块
建议21：i&#43;=1不等于&#43;&#43;i
建议22：使用with自动关闭资源
建议23：使用else子句简化循环（异常处理）
建议24：遵循异常处理的几点基本原则
建议25：避免finally中可能发生的陷阱
建议26：深入理解None，正确判断对象是否为空
建议27：连接字符串应优先使用join而不是&#43;
建议28：格式化字符串时尽量使用.format方式而不是%
建议29：区别对待可变对象和不可变对象
建议30：[]、()和{}：一致的容器初始化形式
建议31：记住函数传参既不是传值也不是传引用
建议32：警惕默认参数潜在的问题
建议33：慎用变长参数
建议34：深入理解str()和repr()的区别
建议35：分清staticmethod和classmethod的适用场景
Chapter 4 建议36：掌握字符串的基本用法
建议37：按需选择sort()或者sorted()
建议38：使用copy模块深拷贝对象
建议39：使用Counter进行计数统计
建议40：深入掌握ConfigParser
建议41：使用argparse处理命令行参数
建议42：使用pandas处理大型CSV文件
建议43：一般情况使用ElementTree解析XML
建议44：理解模块pickle优劣
建议45：序列化的另一个不错的选择——JSON
建议46：使用traceback获取栈信息
建议47：使用logging记录日志信息
建议48：使用threading模块编写多线程程序
建议49：使用Queue使多线程编程更安全
Chapter 5 建议50：利用模块实现单例模式
建议51：用mixin模式让程序更加灵活"/>

    <meta property="og:title" content="读书笔记：《改善 Python 程序的 91 个建议》(1)" />
<meta property="og:description" content="改善 Python 程序的 91 个建议(1) Content: Chapter 1 建议1：理解Pythonic概念
建议2：编写Pythonic代码
建议3：理解Python与C语言的不同之处
建议4：在代码中适当添加注释
建议5：通过适当添加空行使代码布局更为优雅、合理
建议6：编写函数的4个原则
建议7：将常量集中到一个文件
Chapter 2 建议8：利用assert语句来发现问题
建议9：数据交换值的时候不推荐使用中间变量
建议10：充分利用Lazy evaluation的特性
建议11：理解枚举替代实现的缺陷
建议12：不推荐使用type来进行类型检查
建议13：尽量转换为浮点类型后再做除法
建议14：警惕eval()的安全漏洞
建议15：使用enumerate()获取序列迭代的索引和值
建议16：分清==与is的适用场景
建议17：考虑兼容性，尽可能使用Unicode
建议18：构建合理的包层次来管理module
Chapter 3 建议19：有节制地使用from&hellip;import语句
建议20：优先使用absolute import来导入模块
建议21：i&#43;=1不等于&#43;&#43;i
建议22：使用with自动关闭资源
建议23：使用else子句简化循环（异常处理）
建议24：遵循异常处理的几点基本原则
建议25：避免finally中可能发生的陷阱
建议26：深入理解None，正确判断对象是否为空
建议27：连接字符串应优先使用join而不是&#43;
建议28：格式化字符串时尽量使用.format方式而不是%
建议29：区别对待可变对象和不可变对象
建议30：[]、()和{}：一致的容器初始化形式
建议31：记住函数传参既不是传值也不是传引用
建议32：警惕默认参数潜在的问题
建议33：慎用变长参数
建议34：深入理解str()和repr()的区别
建议35：分清staticmethod和classmethod的适用场景
Chapter 4 建议36：掌握字符串的基本用法
建议37：按需选择sort()或者sorted()
建议38：使用copy模块深拷贝对象
建议39：使用Counter进行计数统计
建议40：深入掌握ConfigParser
建议41：使用argparse处理命令行参数
建议42：使用pandas处理大型CSV文件
建议43：一般情况使用ElementTree解析XML
建议44：理解模块pickle优劣
建议45：序列化的另一个不错的选择——JSON
建议46：使用traceback获取栈信息
建议47：使用logging记录日志信息
建议48：使用threading模块编写多线程程序
建议49：使用Queue使多线程编程更安全
Chapter 5 建议50：利用模块实现单例模式
建议51：用mixin模式让程序更加灵活" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ffflora.github.io/cn/solid-python/" />
<meta property="article:published_time" content="2020-03-18T17:08:10-07:00" />
<meta property="article:modified_time" content="2020-03-18T17:08:10-07:00" />


    
      <base href="https://ffflora.github.io/cn/solid-python/">
    
    <title>
  读书笔记：《改善 Python 程序的 91 个建议》(1) · Flora&#39;s
</title>

    
      <link rel="canonical" href="https://ffflora.github.io/cn/solid-python/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://ffflora.github.io/css/coder.min.4c6fcdf76ee3d92d0bdf8069e772433840f81d68ed1e743b0d7a09ca0cd4421d.css" integrity="sha256-TG/N927j2S0L34Bp53JDOED4HWjtHnQ7DXoJygzUQh0=" crossorigin="anonymous" media="screen" />
    

    

    

    

    
    
    <link rel="icon" type="image/png" href="https://ffflora.github.io/img/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://ffflora.github.io/img/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.57.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://ffflora.github.io/">
      Flora&#39;s
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://ffflora.github.io/posts/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://ffflora.github.io/resume.pdf">Resume</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://ffflora.github.io/cn/">CHN</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>读书笔记：《改善 Python 程序的 91 个建议》(1)</h1>
    </header>

    

<h1 id="改善-python-程序的-91-个建议-1">改善 Python 程序的 91 个建议(1)</h1>

<h3 id="content">Content:</h3>

<h4 id="chapter-1">Chapter 1</h4>

<p>建议1：理解Pythonic概念</p>

<p>建议2：编写Pythonic代码</p>

<p>建议3：理解Python与C语言的不同之处</p>

<p>建议4：在代码中适当添加注释</p>

<p>建议5：通过适当添加空行使代码布局更为优雅、合理</p>

<p>建议6：编写函数的4个原则</p>

<p>建议7：将常量集中到一个文件</p>

<h4 id="chapter-2">Chapter 2</h4>

<p>建议8：利用assert语句来发现问题</p>

<p>建议9：数据交换值的时候不推荐使用中间变量</p>

<p>建议10：充分利用Lazy evaluation的特性</p>

<p>建议11：理解枚举替代实现的缺陷</p>

<p>建议12：不推荐使用type来进行类型检查</p>

<p>建议13：尽量转换为浮点类型后再做除法</p>

<p>建议14：警惕eval()的安全漏洞</p>

<p>建议15：使用enumerate()获取序列迭代的索引和值</p>

<p>建议16：分清==与is的适用场景</p>

<p>建议17：考虑兼容性，尽可能使用Unicode</p>

<p>建议18：构建合理的包层次来管理module</p>

<h4 id="chapter-3">Chapter 3</h4>

<p>建议19：有节制地使用from&hellip;import语句</p>

<p>建议20：优先使用absolute import来导入模块</p>

<p>建议21：i+=1不等于++i</p>

<p>建议22：使用with自动关闭资源</p>

<p>建议23：使用else子句简化循环（异常处理）</p>

<p>建议24：遵循异常处理的几点基本原则</p>

<p>建议25：避免finally中可能发生的陷阱</p>

<p>建议26：深入理解None，正确判断对象是否为空</p>

<p>建议27：连接字符串应优先使用join而不是+</p>

<p>建议28：格式化字符串时尽量使用.format方式而不是%</p>

<p>建议29：区别对待可变对象和不可变对象</p>

<p>建议30：[]、()和{}：一致的容器初始化形式</p>

<p>建议31：记住函数传参既不是传值也不是传引用</p>

<p>建议32：警惕默认参数潜在的问题</p>

<p>建议33：慎用变长参数</p>

<p>建议34：深入理解str()和repr()的区别</p>

<p>建议35：分清staticmethod和classmethod的适用场景</p>

<h4 id="chapter-4">Chapter 4</h4>

<p>建议36：掌握字符串的基本用法</p>

<p>建议37：按需选择sort()或者sorted()</p>

<p>建议38：使用copy模块深拷贝对象</p>

<p>建议39：使用Counter进行计数统计</p>

<p>建议40：深入掌握ConfigParser</p>

<p>建议41：使用argparse处理命令行参数</p>

<p>建议42：使用pandas处理大型CSV文件</p>

<p>建议43：一般情况使用ElementTree解析XML</p>

<p>建议44：理解模块pickle优劣</p>

<p>建议45：序列化的另一个不错的选择——JSON</p>

<p>建议46：使用traceback获取栈信息</p>

<p>建议47：使用logging记录日志信息</p>

<p>建议48：使用threading模块编写多线程程序</p>

<p>建议49：使用Queue使多线程编程更安全</p>

<h4 id="chapter-5">Chapter 5</h4>

<p>建议50：利用模块实现单例模式</p>

<p>建议51：用mixin模式让程序更加灵活</p>

<p>建议52：用发布订阅模式实现松耦合</p>

<p>建议53：用状态模式美化代码</p>

<h4 id="chapter-6">Chapter 6</h4>

<p>建议54：理解built-in objects</p>

<p>建议55：<strong>init</strong>()不是构造方法</p>

<p>建议56：理解名字查找机制</p>

<p>建议57：为什么需要self参数</p>

<p>建议58：理解MRO与多继承</p>

<p>建议59：理解描述符机制</p>

<p>建议60：区别<strong>getattr</strong>()和<strong>getattribute</strong>()方法</p>

<p>建议61：使用更为安全的property</p>

<p>建议62：掌握metaclass</p>

<p>建议63：熟悉Python对象协议</p>

<p>建议64：利用操作符重载实现中缀语法</p>

<p>建议65：熟悉 Python 的迭代器协议</p>

<p>建议66：熟悉 Python 的生成器</p>

<p>建议67：基于生成器的协程及greenlet</p>

<p>建议68：理解GIL的局限性</p>

<p>建议69：对象的管理与垃圾回收</p>

<h4 id="chapter-7">Chapter 7</h4>

<p>建议70：从PyPI安装包</p>

<p>建议71：使用pip和yolk安装、管理包</p>

<p>建议72：做paster创建包</p>

<p>建议73：理解单元测试概念</p>

<p>建议74：为包编写单元测试</p>

<p>建议75：利用测试驱动开发提高代码的可测性</p>

<p>建议76：使用Pylint检查代码风格</p>

<p>建议77：进行高效的代码审查</p>

<p>建议78：将包发布到PyPI</p>

<h4 id="chapter-8">Chapter 8</h4>

<p>建议79：了解代码优化的基本原则</p>

<p>建议80：借助性能优化工具</p>

<p>建议81：利用cProfile定位性能瓶颈</p>

<p>建议82：使用memory_profiler 和 objgraph 剖析内存使用</p>

<p>建议83：努力降低算法复杂度</p>

<p>建议84：掌握循环优化的基本技巧</p>

<p>建议85：使用生成器提高效率</p>

<p>建议86：使用不同的数据结构优化性能</p>

<p>建议87：充分利用set的优势</p>

<p>建议88：使用multiprocessing克服GIL的缺陷</p>

<p>建议89：使用线程池提高效率</p>

<p>建议90：使用C/C++模块扩展提高性能</p>

<p>建议91：使用 Cython 编写扩展模块</p>

<hr />

<h3 id="建议-2-编写-pythonic-代码">建议 2：编写 Pythonic 代码</h3>

<p>推荐深入学习 Flask、gevent 和 requests。</p>

<p><code>PEP8</code> 不是唯一的编程规范。有些公司制定的编程规范也非常有参考意义，比如 <code>Google Python Style Guide</code>。同样，<code>PEP8</code> 也不是唯一的风格检测程序，类似的应用还有 <code>Pychecker、Pylint、Pyflakes</code> 等。其中 <code>Pychecker</code> 是 <code>Google Python Style Guide</code> 推荐的工具；<code>Pylint</code> 因可以非常方便地通过编辑配置文件实现公司或团队的风格检测而受到许多人的青睐；<code>Pyflakes</code> 则因为易于集成到 vim 中，所以使用的人也非常多。</p>

<h3 id="建议-4-在代码中适当添加注释">建议 4：在代码中适当添加注释</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="font-weight:bold">def</span> FuncName(parameter1 , parameter2):
    <span style="font-style:italic">&#34;&#34;&#34;Describe what this function does.
</span><span style="font-style:italic">    #such as &#34;Find whether the special string is in the queue or not&#34;
</span><span style="font-style:italic">    Args:
</span><span style="font-style:italic">        parameter1: parameter type, what is this parameter used for.
</span><span style="font-style:italic">        	#such as strqueue:string,string queue list for search
</span><span style="font-style:italic">        parameter2: parameter type, what is this parameter used for.
</span><span style="font-style:italic">        	#such as str:string,string to find
</span><span style="font-style:italic">    Returns:
</span><span style="font-style:italic">    	return type, return value.
</span><span style="font-style:italic">    		#such as  boolean,sepcial string  found return True,else return False
</span><span style="font-style:italic">    &#34;&#34;&#34;</span>
	function body
	...
	...</code></pre></div>
<p>推荐在头文件中包含 copyright 申明、模块描述等，如有必要，可以考虑加入作者信息以及变更记录。</p>

<p>对于不再需要的代码，应该将其删除，而不是将其注释掉。</p>

<h3 id="建议-5-通过适当添加空行使代码布局更为优雅-合理">建议 5：通过适当添加空行使代码布局更为优雅、合理</h3>

<p>在一组代码表达完一个完整的思路之后，应该用空白行进行间隔</p>

<p>避免过长的代码行，每行最好不要超过80个字符</p>

<p>不要为了保持水平对齐而使用多余的空格</p>

<p>逗号和分号前不要使用空格</p>

<h3 id="建议-6-编写函数的-4-个原则">建议 6：编写函数的 4 个原则</h3>

<p>函数能够带来<strong>最大化的代码重用和最小化的代码冗余</strong>。</p>

<ol>
<li>函数设计要尽量短小，嵌套层次不宜过深</li>
<li>函数申明应该做到合理、简单、易于使用</li>
<li>更好的方法是通过加入默认参数来避免这种退化，函数参数设计应该考虑向下兼容</li>
<li>一个函数只做一件事，尽量保证函数语句粒度的一致性</li>
<li>不要在函数中定义可变对象作为默认值，使用异常替换返回错误，保证通过单元测试等。</li>
<li>应该尽量避免使用eval，在需要使用eval的地方可用安全性更好的ast.literal_eval替代</li>
</ol>

<h3 id="建议-7-将常量集中到一个文件">建议 7：将常量集中到一个文件</h3>

<p>在 Python 中应当如何使用常量：</p>

<ul>
<li>通过命名风格提醒使用者该变量代表常量，如常量名全部大写</li>
<li>通过自定义类实现常量功能：将存放常量的文件命名为constant.py，并在其中定义一系列常量</li>
</ul>

<p>无论采用哪一种方式来实现常量，都提倡将常量集中到一个文件中，因为这样有利于维护，一旦需要修改常量的值，可以集中统一进行而不是逐个文件去检查</p>

<h3 id="建议-8-利用-assert-语句来发现问题">建议 8：利用 assert 语句来发现问题</h3>

<p>assert 实际是被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此使用断言需要注意以下几点：</p>

<ol>
<li><p>不要滥用，这是使用断言最基本的原则。</p></li>

<li><p>如果Python本身的异常能够处理就不要再使用断言</p></li>

<li><p>不要使用断言来检查用户的输入。如对于一个数字类型，如果根据用户的设计该值的范围应该是2～10，较好的做法是使用条件判断，并在不符合条件的时候输出错误提示信息。</p></li>

<li><p>在函数调用后，当需要确认返回值是否合理时可以使用断言</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; y = 2
&gt;&gt;&gt; <span style="font-weight:bold">assert</span> x == y, <span style="font-style:italic">&#34;not equals&#34;</span>
Traceback (most recent call last):
File <span style="font-style:italic">&#34;&lt;stdin&gt;&#34;</span>, line 1, <span style="font-weight:bold">in</span> &lt;module&gt;
<span style="font-weight:bold">AssertionError</span>: <span style="font-weight:bold">not</span> equals
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 2
<span style="font-style:italic"># 以上代码相当于</span>
&gt;&gt;&gt; <span style="font-weight:bold">if</span> __debug__ <span style="font-weight:bold">and</span> <span style="font-weight:bold">not</span> x == y:
...     <span style="font-weight:bold">raise</span> <span style="font-weight:bold">AssertionError</span>(<span style="font-style:italic">&#34;not equals&#34;</span>)
... 
Traceback (most recent call last):
File <span style="font-style:italic">&#34;&lt;stdin&gt;&#34;</span>, line 2, <span style="font-weight:bold">in</span> &lt;module&gt;
<span style="font-weight:bold">AssertionError</span>: <span style="font-weight:bold">not</span> equals</code></pre></div></li>
</ol>

<p>运行是加入-O参数可以禁用断言。</p>

<h3 id="建议-9-数据交换的时候不推荐使用中间变量">建议 9：数据交换的时候不推荐使用中间变量</h3>

<p>一般情况下Python表达式的计算顺序是从左到右，但遇到表达式赋值的时候表达式右边的操作数先于左边的操作数计算。</p>

<h3 id="建议-10-充分利用-lazy-evaluation-的特性">建议 10：充分利用 Lazy evaluation 的特性</h3>

<p>避免不必要的计算，带来性能上的提升。对于Python中的条件表达式 <code>if x and y</code>，在x为false的情况下y表达式的值将不再计算。而对于<code>if x or y</code>，当x的值为true的时候将直接返回，不再计算y的值。因此编程中应该充分利用该特性。</p>

<p>因此在编程过程中，<strong>如果对于or条件表达式应该将值为真可能性较高的变量写在or的前面，而and则应该推后。</strong></p>

<h3 id="建议-12-不推荐使用-type-来进行类型检查">建议 12：不推荐使用 type 来进行类型检查</h3>

<p>基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。</p>

<p>如果类型有对应的工厂函数，可以使用工厂函数对类型做相应转换，如list(listing)、str(name)等，否则可以使用isinstance()函数来检测: <code>isinstance(object, classinfo)</code></p>

<h3 id="建议-14-警惕-eval-的安全漏洞">建议 14：警惕 eval() 的安全漏洞</h3>

<p>Python中eval()函数将字符串str当成有效的表达式来求值并返回计算结果。</p>

<p>“eval is evil”（eval是邪恶的），这是一句广为人知的对eval的评价，它主要针对的是eval()的<strong>安全性</strong>。</p>

<p>eval(expression[,  globals[, locals]])将字符串 str  当成有效的表达式来求值并返回计算结果，globas为字典形式，locals为任何映射对象，它们分别表示全局和局部命名空间，两者都省略表达式将在调用的环境中执行，为什么需要警惕eval()呢：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; eval(<span style="font-style:italic">&#39;__import__(&#34;os&#34;).system(&#34;dir&#34;)&#39;</span>)
Desktop  Documents  Downloads  examples.desktop  Music  Pictures  Public  __pycache__  Templates  Videos
0
&gt;&gt;&gt; eval(<span style="font-style:italic">&#39;__import__(&#34;os&#34;).system(&#34;del * /Q&#34;)&#39;</span>)   </code></pre></div>
<p>如果确实需要使用<code>eval</code>，建议使用安全性更好的<code>ast.literal_eval</code>。</p>

<h3 id="建议-15-使用-enumerate-获取序列迭代的索引和值">建议 15：使用 enumerate() 获取序列迭代的索引和值</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; li = [<span style="font-style:italic">&#39;a&#39;</span>, <span style="font-style:italic">&#39;b&#39;</span>, <span style="font-style:italic">&#39;c&#39;</span>, <span style="font-style:italic">&#39;d&#39;</span>, <span style="font-style:italic">&#39;e&#39;</span>]
&gt;&gt;&gt; <span style="font-weight:bold">for</span> i, e <span style="font-weight:bold">in</span> enumerate(li):
...     <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;index: &#39;</span>, i, <span style="font-style:italic">&#39;element: &#39;</span>, e)
... 
index:  0 element:  a
index:  1 element:  b
index:  2 element:  c
index:  3 element:  d
index:  4 element:  e
<span style="font-style:italic"># enumerate(squence, start=0) 内部实现</span>
<span style="font-weight:bold">def</span> enumerate(squence, start=0):
    n = start
    <span style="font-weight:bold">for</span> elem <span style="font-weight:bold">in</span> sequence:
        <span style="font-weight:bold">yield</span> n, elem   <span style="font-style:italic"># 666</span>
        n += 1
<span style="font-style:italic"># 明白了原理我们自己也来实现一个反序的</span>
<span style="font-weight:bold">def</span> reversed_enumerate(squence):
    n = -1
    <span style="font-weight:bold">for</span> elem <span style="font-weight:bold">in</span> reversed(sequence):
        <span style="font-weight:bold">yield</span> len(sequence) + n, elem
        n -= 1</code></pre></div>
<h3 id="建议-16-分清-与-is-的适用场景">建议 16：分清 == 与 is 的适用场景</h3>

<p>操作符意义isobject identity==equal</p>

<p>is的作用是用来检查对象的标示符是否一致，也就是比较两个对象在内存中是否拥有同一块内存空间，相当于id(x)  ==  id(y)，它并不适用于判断两个字符串是否相等。<code>==</code>才是用来判断两个对象的值是否相等，实际是调用了内部的<strong>eq</strong>，<code>==</code>所以ab相当于a.<strong>eq</strong>(b)，也就是说==是可以被重载的，而is不能被重载。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; s1 = <span style="font-style:italic">&#39;hello world&#39;</span>
&gt;&gt;&gt; s2 = <span style="font-style:italic">&#39;hello world&#39;</span>
&gt;&gt;&gt; s1 == s2
True
&gt;&gt;&gt; s1 <span style="font-weight:bold">is</span> s2
False
&gt;&gt;&gt; s1.__eq__(s2)
True
&gt;&gt;&gt; a = <span style="font-style:italic">&#39;Hi&#39;</span>
&gt;&gt;&gt; b = <span style="font-style:italic">&#39;Hi&#39;</span>
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a <span style="font-weight:bold">is</span> b
True</code></pre></div>
<p>咦~怎么上例中的a, b又是“同一对象”了？这跟 Python 的 string interning 机制有关，为了提高系统性能，对于<strong>较小的字符串</strong>会保留其值的一个副本，当创建新的字符串时直接指向该副本，所以a和b的 id 值是一样的，同样对于小整数[-5, 257)也是如此：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; id(a)
140709793837832
&gt;&gt;&gt; id(b)
140709793837832
&gt;&gt;&gt; x = -5
&gt;&gt;&gt; y = -5
&gt;&gt;&gt; x <span style="font-weight:bold">is</span> y
True
&gt;&gt;&gt; id(x) == id(y)
True</code></pre></div>
<h3 id="建议-17-考虑兼容性-尽可能使用-unicode">建议 17：考虑兼容性，尽可能使用 Unicode</h3>

<p>我之前也总结过编码的问题。由于最早的编码是 ASCII 码，只能表示 128 个字符，显然这对其它语言编码并不适用，Unicode就是为了不同的文字分配一套统一的编码。</p>

<h3 id="建议-18-构建合理的包层次来管理-module">建议 18：构建合理的包层次来管理 module</h3>

<p>本质上每一个 Python 文件都是一个模块，使用模块可以增强代码的可维护性和可重用性，在较大的项目中，我们需要合理地组织项目层次来管理模块，这就是包(Package)的作用。</p>

<p>一句话说包：一个包含<strong>init</strong>.py   文件的目录。包中的模块可以通过.进行访问，即包名.模块名。那么这个<strong>init</strong>.py文件有什么用呢？最明显的作用就是它区分了包和普通目录，在该文件中申明模块级别的  import 语句从而变成了包级别可见，另外在该文件中定义<strong>all</strong>变量，可以控制需要导入的子包或模块。</p>

<p>这里给出一个较为合理的包组织方式，是<a href="https://link.zhihu.com/?target=https%3A//item.jd.com/11594082.html">FlaskWeb 开发：基于Python的Web应用开发实战</a>一书中推荐而来的：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">|-flasky
    |-app/                      <span style="font-style:italic"># Flask 程序</span>
        |-templates/            <span style="font-style:italic"># 存放模板</span>
        |-static/               <span style="font-style:italic"># 静态文件资源</span>
        |-main/
            |-__init__.py
            |-errors.py         <span style="font-style:italic"># 蓝本中的错误处理程序</span>
            |-forms.py          <span style="font-style:italic"># 表单对象</span>
            |-views.py          <span style="font-style:italic"># 蓝本中定义的程序路由</span>
        |-__init__.py
        |-email.py              <span style="font-style:italic"># 电子邮件支持</span>
        |-models.py             <span style="font-style:italic"># 数据库模型</span>
    |-migrations/               <span style="font-style:italic"># 数据库迁移脚本</span>
    |-tests/                    <span style="font-style:italic"># 单元测试</span>
        |-__init__.py
        |-test*.py
    |-venv/                     <span style="font-style:italic"># 虚拟环境</span>
    |-requirements/
        |-dev.txt               <span style="font-style:italic"># 开发过程中的依赖包</span>
        |-prod.txt              <span style="font-style:italic"># 生产过程中的依赖包</span>
    |-config.py                 <span style="font-style:italic"># 储存程序配置</span>
    |-manage.py                 <span style="font-style:italic"># 启动程序以及其他的程序任务</span></code></pre></div>
<h2 id="第-3-章-基础语法">第 3 章：基础语法</h2>

<h3 id="建议-19-有节制地使用-from-import-语句">建议 19：有节制地使用 from&hellip;import 语句</h3>

<p>Python 提供三种方式来引入外部模块：import语句、from&hellip;import语句以及<strong>import</strong>函数，其中<strong>import</strong>函数显式地将模块的名称作为字符串传递并赋值给命名空间的变量。</p>

<p>使用import需要注意以下几点：</p>

<ul>
<li>优先使用import a的形式</li>
<li>有节制地使用from a import A</li>
<li>尽量避免使用from a import *</li>
</ul>

<p>为什么呢？我们来看看  Python 的 import 机制，Python  在初始化运行环境的时候会预先加载一批内建模块到内存中，同时将相关信息存放在sys.modules中，我们可以通过sys.modules.items()查看预加载的模块信息，当加载一个模块时，解释器实际上完成了如下动作：</p>

<ol>
<li>在sys.modules中搜索该模块是否存在，如果存在就导入到当前局部命名空间，如果不存在就为其创建一个字典对象，插入到sys.modules中</li>
<li>加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译</li>

<li><p>执行动态加载，在当前命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; dir()
[<span style="font-style:italic">&#39;__builtins__&#39;</span>, <span style="font-style:italic">&#39;__doc__&#39;</span>, <span style="font-style:italic">&#39;__loader__&#39;</span>, <span style="font-style:italic">&#39;__name__&#39;</span>, <span style="font-style:italic">&#39;__package__&#39;</span>, <span style="font-style:italic">&#39;__spec__&#39;</span>]
&gt;&gt;&gt; <span style="font-weight:bold">import</span> <span style="font-weight:bold">test</span>
testing module <span style="font-weight:bold">import</span>
&gt;&gt;&gt; dir()
[<span style="font-style:italic">&#39;__builtins__&#39;</span>, <span style="font-style:italic">&#39;__doc__&#39;</span>, <span style="font-style:italic">&#39;__loader__&#39;</span>, <span style="font-style:italic">&#39;__name__&#39;</span>, <span style="font-style:italic">&#39;__package__&#39;</span>, <span style="font-style:italic">&#39;__spec__&#39;</span>, <span style="font-style:italic">&#39;test&#39;</span>]
&gt;&gt;&gt; <span style="font-weight:bold">import</span> <span style="font-weight:bold">sys</span>
&gt;&gt;&gt; <span style="font-style:italic">&#39;test&#39;</span> <span style="font-weight:bold">in</span> sys.modules.keys()
True
&gt;&gt;&gt; id(test)
140367239464744
&gt;&gt;&gt; id(sys.modules[<span style="font-style:italic">&#39;test&#39;</span>])
140367239464744
&gt;&gt;&gt; dir(test)
[<span style="font-style:italic">&#39;__builtins__&#39;</span>, <span style="font-style:italic">&#39;__cached__&#39;</span>, <span style="font-style:italic">&#39;__doc__&#39;</span>, <span style="font-style:italic">&#39;__file__&#39;</span>, <span style="font-style:italic">&#39;__loader__&#39;</span>, <span style="font-style:italic">&#39;__name__&#39;</span>, <span style="font-style:italic">&#39;__package__&#39;</span>, <span style="font-style:italic">&#39;__spec__&#39;</span>, <span style="font-style:italic">&#39;a&#39;</span>, <span style="font-style:italic">&#39;b&#39;</span>]
&gt;&gt;&gt; sys.modules[<span style="font-style:italic">&#39;test&#39;</span>].__dict__.keys()
dict_keys([<span style="font-style:italic">&#39;__file__&#39;</span>, <span style="font-style:italic">&#39;__builtins__&#39;</span>, <span style="font-style:italic">&#39;__doc__&#39;</span>, <span style="font-style:italic">&#39;__loader__&#39;</span>, <span style="font-style:italic">&#39;__package__&#39;</span>, <span style="font-style:italic">&#39;__spec__&#39;</span>, <span style="font-style:italic">&#39;__name__&#39;</span>, <span style="font-style:italic">&#39;b&#39;</span>, <span style="font-style:italic">&#39;a&#39;</span>, <span style="font-style:italic">&#39;__cached__&#39;</span>])</code></pre></div></li>
</ol>

<p>从上可以看出，对于用户自定义的模块，import 机制会创建一个新的 module 将其加入当前的局部命名空间中，同时在 sys.modules 也加入该模块的信息，但本质上是在引用同一个对象，通过test.py所在的目录会多一个字节码文件。</p>

<h3 id="建议-21-i-1-不等于-i">建议 21： i+=1 不等于 ++i</h3>

<p>首先++i或&ndash;i在 Python 语法上是合法，但并不是我们通常理解的自增或自减操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; ++1     <span style="font-style:italic"># +(+1)</span>
1
&gt;&gt;&gt; --1     <span style="font-style:italic"># -(-1)</span>
1
&gt;&gt;&gt; +++2
2
&gt;&gt;&gt; ---2
-2</code></pre></div>
<p>原来<code>+</code>或<code>-</code>只表示正负数符号。</p>

<h3 id="建议-22-使用-with-自动关闭资源">建议 22：使用 with 自动关闭资源</h3>

<p>对于打开的资源我们记得关闭它，如文件、数据库连接等，Python 提供了一种简单优雅的解决方案：with。</p>

<p>先来看with实现的原理吧。</p>

<p>with的实现得益于一个称为上下文管理器(context   manager)的东西，它定义程序运行时需要建立的上下文，处理程序的进入和退出，实现了上下文管理协议，即对象中定义了<strong>enter</strong>()和<strong>exit</strong>()，任何实现了上下文协议的对象都可以称为一个上下文管理器：</p>

<ul>
<li><strong>enter</strong>()：返回运行时上下文相关的对象</li>
<li><strong>exit</strong>(exception_type, exception_value, traceback)：退出运行时的上下文，处理异常、清理现场等</li>
</ul>

<p>包含with语句的代码块执行过程如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="font-weight:bold">with</span> <span style="">表达式</span> [<span style="font-weight:bold">as</span> <span style="">目标</span>]:


&gt;&gt;&gt; <span style="font-weight:bold">with</span> open(<span style="font-style:italic">&#39;test.txt&#39;</span>, <span style="font-style:italic">&#39;w&#39;</span>) <span style="font-weight:bold">as</span> f:
...     f.write(<span style="font-style:italic">&#39;test&#39;</span>)
... 

&gt;&gt;&gt; f.__enter__
&lt;built-<span style="font-weight:bold">in</span> method __enter__ of _io.TextIOWrapper object at 0x7f1b967aaa68&gt;
&gt;&gt;&gt; f.__exit__
&lt;built-<span style="font-weight:bold">in</span> method __exit__ of _io.TextIOWrapper object at 0x7f1b967aaa68&gt;</code></pre></div>
<ol>
<li>计算表达式的值，返回一个上下文管理器对象</li>
<li>加载上下文管理器对象的<strong>exit</strong>()以备后用</li>
<li>调用上下文管理器对象的<strong>enter</strong>()</li>
<li>将<strong>enter</strong>()的返回值赋给目标对象</li>
<li>执行代码块，正常结束调用<strong>exit</strong>()，其返回值直接忽略，如果发生异常，会调用<strong>exit</strong>()并将异常类型、值及  traceback 作为参数传递给<strong>exit</strong>()，<strong>exit</strong>()返回值为 false 异常将会重新抛出，返回值为 true  异常将被挂起，程序继续执行</li>
</ol>

<p>于此，我们可以自定义一个上下文管理器：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; <span style="font-weight:bold">class</span> <span style="font-weight:bold">MyContextManager</span>(object):
...     <span style="font-weight:bold">def</span> __enter__(self):
...         <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;entering...&#39;</span>)
...     <span style="font-weight:bold">def</span> __exit__(self, exception_type, exception_value, traceback):
...         <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;leaving...&#39;</span>)
...         <span style="font-weight:bold">if</span> exception_type <span style="font-weight:bold">is</span> None:
...             <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;no exceptions!&#39;</span>)
...             <span style="font-weight:bold">return</span> False
...         <span style="font-weight:bold">elif</span> exception_type <span style="font-weight:bold">is</span> <span style="font-weight:bold">ValueError</span>:
...             <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;value error!&#39;</span>)
...             <span style="font-weight:bold">return</span> True
...         <span style="font-weight:bold">else</span>:
...             <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;other error&#39;</span>)
...             <span style="font-weight:bold">return</span> True
... 
&gt;&gt;&gt; <span style="font-weight:bold">with</span> MyContextManager():
...     <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;Testing...&#39;</span>)
... 
entering...
Testing...
leaving...
no exceptions<span style="">!</span>
&gt;&gt;&gt; <span style="font-weight:bold">with</span> MyContextManager():
...     <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;Testing...&#39;</span>)
...     <span style="font-weight:bold">raise</span>(<span style="font-weight:bold">ValueError</span>)
... 
entering...
Testing...
leaving...
value error<span style="">!</span></code></pre></div>
<p>Python 还提供contextlib模块，通过 Generator 实现，其中的 contextmanager 作为装饰器来提供一种针对函数级别上的上下文管理器，可以直接作用于函数/对象而不必关心<strong>enter</strong>()和<strong>exit</strong>()的实现。</p>

<p>推荐<a href="https://link.zhihu.com/?target=http%3A//www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001478651770626de401ff1c0d94f379774cabd842222ff000">文章</a></p>

<h3 id="建议-23-使用-else-子句简化循环-异常处理">建议 23：使用 else 子句简化循环（异常处理）</h3>

<p>Python 的 else 子句提供了隐含的对循环是否由 break 语句引发循环结束的判断，有点绕哈，来看例子：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">&gt;&gt;&gt; <span style="font-weight:bold">def</span> print_prime(n):
...     <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(2, n):
...         <span style="font-weight:bold">for</span> j <span style="font-weight:bold">in</span> range(2, i):
...             <span style="font-weight:bold">if</span> i % j == 0:
...                 <span style="font-weight:bold">break</span>
...         <span style="font-weight:bold">else</span>:
...             <span style="font-weight:bold">print</span>(<span style="font-style:italic">&#39;{} is a prime number&#39;</span>.format(i))
... 
&gt;&gt;&gt; print_prime(7)
2 <span style="font-weight:bold">is</span> a prime number
3 <span style="font-weight:bold">is</span> a prime number
5 <span style="font-weight:bold">is</span> a prime number</code></pre></div>
<p>可以看出，else 子句在循环正常结束和循环条件不成立时被执行，由 break 语句中断时不执行，同样，我们可以利用这颗语法糖作用在 while 和 try&hellip;except 中。</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>Happy Analyzing!</p>
    
    
    
    
  </section>
</footer>

    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-146589116-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
