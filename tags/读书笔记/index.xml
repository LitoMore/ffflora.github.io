<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>读书笔记 on Flora&#39;s</title>
    <link>https://ffflora.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 读书笔记 on Flora&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Mar 2020 17:08:10 -0700</lastBuildDate>
    
	<atom:link href="https://ffflora.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>读书笔记：《改善 Python 程序的 91 个建议》(1)</title>
      <link>https://ffflora.github.io/cn/solid-python/</link>
      <pubDate>Wed, 18 Mar 2020 17:08:10 -0700</pubDate>
      
      <guid>https://ffflora.github.io/cn/solid-python/</guid>
      <description>改善 Python 程序的 91 个建议(1) Content: Chapter 1 建议1：理解Pythonic概念
建议2：编写Pythonic代码
建议3：理解Python与C语言的不同之处
建议4：在代码中适当添加注释
建议5：通过适当添加空行使代码布局更为优雅、合理
建议6：编写函数的4个原则
建议7：将常量集中到一个文件
Chapter 2 建议8：利用assert语句来发现问题
建议9：数据交换值的时候不推荐使用中间变量
建议10：充分利用Lazy evaluation的特性
建议11：理解枚举替代实现的缺陷
建议12：不推荐使用type来进行类型检查
建议13：尽量转换为浮点类型后再做除法
建议14：警惕eval()的安全漏洞
建议15：使用enumerate()获取序列迭代的索引和值
建议16：分清==与is的适用场景
建议17：考虑兼容性，尽可能使用Unicode
建议18：构建合理的包层次来管理module
Chapter 3 建议19：有节制地使用from&amp;hellip;import语句
建议20：优先使用absolute import来导入模块
建议21：i+=1不等于++i
建议22：使用with自动关闭资源
建议23：使用else子句简化循环（异常处理）
建议24：遵循异常处理的几点基本原则
建议25：避免finally中可能发生的陷阱
建议26：深入理解None，正确判断对象是否为空
建议27：连接字符串应优先使用join而不是+
建议28：格式化字符串时尽量使用.format方式而不是%
建议29：区别对待可变对象和不可变对象
建议30：[]、()和{}：一致的容器初始化形式
建议31：记住函数传参既不是传值也不是传引用
建议32：警惕默认参数潜在的问题
建议33：慎用变长参数
建议34：深入理解str()和repr()的区别
建议35：分清staticmethod和classmethod的适用场景
Chapter 4 建议36：掌握字符串的基本用法
建议37：按需选择sort()或者sorted()
建议38：使用copy模块深拷贝对象
建议39：使用Counter进行计数统计
建议40：深入掌握ConfigParser
建议41：使用argparse处理命令行参数
建议42：使用pandas处理大型CSV文件
建议43：一般情况使用ElementTree解析XML
建议44：理解模块pickle优劣
建议45：序列化的另一个不错的选择——JSON
建议46：使用traceback获取栈信息
建议47：使用logging记录日志信息
建议48：使用threading模块编写多线程程序
建议49：使用Queue使多线程编程更安全
Chapter 5 建议50：利用模块实现单例模式
建议51：用mixin模式让程序更加灵活</description>
    </item>
    
    <item>
      <title>读书笔记：《走进内容推荐时代》</title>
      <link>https://ffflora.github.io/cn/rec-sys/</link>
      <pubDate>Tue, 19 Nov 2019 14:22:34 -0800</pubDate>
      
      <guid>https://ffflora.github.io/cn/rec-sys/</guid>
      <description>走进内容推荐时代 : 写给内容行业从业者的推荐分发入门书（市场先行版） ◆ 走近内容推荐 多种召回方式共同构建的视频候选集会被一并送进排序环节。在排序环节中，神经网络基于用户个体的特征和视频的特征对候选集进行打分，最后给用户返回得分靠前的十余个视频。
相对YouTube较为抽象简化的数据流图，Netflix（网飞）的架构图就更复杂一些了，但整体上仍然保持了离线模型训练、在线召回排序、更新用户画像与内容画像的基础结构。
离线模型训练、在线召回排序、更新用户画像与内容画像的基础结构。系统在实时响应用户请求的在线层和负责数据处理、模型训练的离线层之间增加了NearLine（近线）层，以实现计算规模和时效性的折中。
“训练”推荐系统就请你不吝表达和互动，用你的反馈支持服务提供商和内容创作者。对于令你满意的服务和产品，登录是最好的肯定，在登录后，你的所有行为轨迹就不会丢失，在更换设备之后仍然能够获得稳定的服务体验；对于令你满意的内容，请果断地点赞、评论；对于你喜欢的作者，可以关注他的后续动态。“赠人玫瑰、手有余香”，这些典型正向反馈能够让算法更快速地收敛并确定你的喜好。对于令你厌恶的内容，也请点个“×”，明确屏蔽掉特定关键字，让系统不再做无用的探索。
完善用户画像既可以通过尽可能多的外部渠道数据塑造用户来实现，也可以借助产品设计和运营活动引导用户多沉淀行为来实现。
规则是在排序环节之后生效的
短期的干预是应该逐步被长期的机制所替换的。
◆ 推荐的起点：断物识人 在我们设计系统时，可以先基于产品场景快速覆盖主要标签，再结合标签集合的使用频次、专家建议等因素逐步将部分入口收敛到树状的分类体系中来。
简短评论：最高门槛的评判，深度用户沉淀内容
在这种情况下，我们需要引入聚类的方式来描述。这种方式并不是以标签词的方式来定义事物是怎样的，而是基于某一维度的特征将相关物品组成一个集合，并告诉你这个新的物品同哪个集合相似。 clustering the similar items depending on the feature of some dimensions, and classify the new item to the most similar cluster
通常，用户画像有三类主要应用场景：
（1）精准广告营销。用户画像对广告营销来说是最典型的应用场景。当给用户打上各种维度的标签之后，广告主就能够借助这些标签来圈定用户，以便更有效率地触达目标人群。我们以脸谱网的广告投放系统为例，广告主可以选择地域范围、年龄范围、性别、兴趣标签等。通过选择这一系列标签，系统也会实时反馈给广告主目前框定的候选人数。
（2）行业研究。借助用户画像，我们可以了解不同行业的动态进展。比如，90后、00后的购物娱乐消费分析，不同地域用户的消费差异分析，特定行业中用户的消费特点，等等。通常，平台会定期发布此类报告，帮助内外部人士更好地了解细分领域的最新特点。比如，在腾讯大数据（http://bigdata.qq.com/reports）上，你就可以查看到过往发布的行业研究报告。
（3）产品效率优化。信息匹配是最典型的场景，无论是国内的今日头条、淘宝，还是国外的YouTube、脸谱网，其平台都是基于用户的画像信息来优化推荐排序，以实现人和信息的高效匹配，从而提升效益、降低成本的。据Netflix估算，个性化推荐系统每年为它的业务节省的费用高达10亿美元。坊间传闻，基于用户画像的推荐排序还有一些灰色的应用：比如真假货混发，罗振宇在跨年演讲“时间的朋友”中提到，某不良商家会根据用户的收货地址来预估用户的认知水平，从而决定是发送真货、高仿还是假货；又比如价格歧视，同样一件商品添加进购物车后，不同的用户可能会收到不同的后续反馈，价格敏感型的用户更容易收到优惠券。
我们通常将用户画像数据划分为静态和动态两类。静态用户画像数据：用户独立于产品场景之外的属性，如性别、学历、年龄、婚育状况、常驻位置等。这些信息往往相对稳定，可通过第三方联合登录、用户表单填写等方式获取。静态数据通常具有统计性意义，比如常驻位置在某高档小区的用户可能付费能力更强，女性用户可能冲动性消费更多等。动态用户画像数据：用户在产品场景中所产生的显式或隐式行为。显式行为包括对某篇内容点赞、评论、分享，关注了某个作者等。在众多显式行为中，由于产品场景的不同，不同行为的权重也不相同（如对于电商场景，购买的权重&amp;gt;购物车的权重&amp;gt;查看的权重）。隐式行为包括在某页面的停留时长、用户的操作行为轨迹等。通常，显式行为的权重要高于隐式行为，但是由于显式行为更稀疏，所以需要隐式行为来补充验证。
以下是一些常见的静态或动态用户画像数据： 位置信息。不同产品对常驻位置有不同的应用方式：推荐本地新闻和特定水电暖通知之类的内容是能够想到的最直观的应用场景；美食团购类应用，是默认基于身边位置进行推荐的。但是，当你离开常驻城市进入其他城市时就会发现，应用中会增加一个旅行者模块，其提供的内容更多考虑知名度而非距离因素。[插图]图2-8 美食团购类应用基于位置推荐示例除了常驻城市的应用外，对于朝九晚五的上班族来说，还有常驻地点的概念，如高德地图和滴滴打车中提供的“家”和“公司”的选项。基于日常轨迹和常驻地点，系统可以进行一些远距离的推荐，如可以在下班时段推荐家附近的饮食或尝试推荐沿途的消费地点。
搜索信息。搜索是一个显著表明短期意图的行为，具有随时间衰减的特性。以淘宝为例，当你搜索“螃蟹”之后，那么无论是在淘宝的首页横幅广告，还是在接入了淘宝广告的应用，你都能看到关于“螃蟹”的广告。而当搜索行为过去一段时间或是在你显式购买之后，这类广告的展现就应该降低或停止。
评分。评分是最常见的量化行为。如淘宝、京东等购物网站对购物行为不同维度的点评，豆瓣对书籍和电影的打分等，一般都设置为1～5分的评分机制。需要注意的是，不同用户有不同的打分偏好，比如有人习惯性好评，有人则偏严格。因此，需要将用户的历史平均分作为基准进行归一化处理，以衡量用户评分行为背后的认可度。
收藏。收藏表达了用户对内容的偏好程度。在内容领域，具有工具性或实用性的内容通常更容易被收藏。在电商领域，收藏和加入购物车一样都是用户购买意图的体现。
分享。除了表达喜好外，分享还传递了用户的立场和态度。比如，用户会阅读、评论很多热门的内容，但在转发的操作上是审慎的。转发到微博或微信朋友圈的动作代表了用户在用自己的社会身份扩散内容。从某种角度而言，转发的肯定意义比收藏、评论等行为的意义要大。
评论。评论代表了参与度，但不一定明确地关联到态度的好恶。对评论的处理需要进一步进行文本分析，以获取用户的表意性和情感倾向性。在产品层上，淘宝的宝贝印象算是一个典型应用，通过抽离出用户的共同评语来辅助新的消费者进行决策。
播放比例或播放时长。与点击行为相比，播放时长是一个相对隐性的行为。我们通常可以用播放时长来衡量用户对特定视频点击后的消费体验。2012年，YouTube就已经调整视频排序算法，将获得观看时长更多的视频排在更优先的位置。
◆ 推荐算法：物以类聚，人以群分 推荐算法：物以类聚，人以群分
以内容推荐为例，其用于相似度计算的常见因素有：作者层面的相似性（基于订阅或偏好关系），内容层面的相似性（如关键词、话题、类目、聚类、标签等）。
基于内容属性推荐的好处在于，只依赖物品本身的特征而不依赖用户的行为，让新的物品、冷僻的物品都能得到展示的机会。其存在的问题在于，推荐质量的优劣完全依赖于特征构建的完备性，但特征构建本身是一项系统的工程，存在一定成本。在上面的例子中，如果标签词粒度不够细，不能够全面描述书的内容（比如每本书的标签词只有三个），就很难计算出置信的相似度，达不到足够好的推荐效果。
人以群分：基于用户行为的协同过滤
把用户的消费行为作为特征，以此进行用户相似性或物品相似性的计算，进行信息匹配，是协同过滤（Collaborative Filtering）的基础。
协同推荐可以分为三个子类：基于物品（Item-based）的协同、基于用户（User-based）的协同和基于模型（Model-based）的协同。
基于用户的协同就契合了上面的例子，其基础思路分为两步：第一步，找到那些与你在某一方面口味相似的人群（比如你们都是新手爸妈，倾向于同一种教育理念）；第二步，将这一人群喜欢的新东西推荐给你。
基于物品的协同，其推荐的基础思路是：先确定你喜欢什么物品，再找到与之相似的物品推荐给你。只是物品与物品间的相似度不是从内容属性的角度衡量的，而是从用户反馈的角度衡量的。
大家一度认为基于物品的协同要优于基于用户的协同，这是因为大型电商网站的用户数量往往远大于商品数量，且商品的更新频率相对较低，基于物品的协同能够以离线运算的方式获得更好的推荐效果。但对新闻推荐系统、社交性推荐系统等而言，其物品是海量和频繁更新的，故而基于用户的协同也有着相应的用武之地。
基于模型的协同，是用用户的喜好信息来训练算法模型，实时预测用户可能的点击率
比如，在Netflix的系统中就将受限玻尔兹曼机（Restricted Boltzmann Machines, RBM）神经网络应用于协同过滤。将深度学习应用于基于模型的协同，也成了业界广泛使用的方式。</description>
    </item>
    
  </channel>
</rss>